Detect midi input events
Allow users to hook midi inputs up to controls 

Allow continuous signals = number controls
Allow boolean signals = number and boolean controls

On visualizer launch, detect midi device inputs.

Scalability user case, users have MULTIPLE midi devices that they want to control vis with
They can press the midi listen button and then select a midi control they want to use

If they press the midi listen button again we handle the following two cases
	The new input has the same device ID as the current one -> we ovewrite the previous midi settings
	The new input has a different device ID -> we add the new midi settings to the current midi settings

This way the user can swap between midi devices without having to reconfigure the midi settings each time.

Problem: If both midi devices are connected at the same time there will be conflicts and double ups of events.
This will only be the case if the user is controlling the same control with two different midi devices. Which is their fault and we don't have to worry about this problem.

With this method the user can also use mulitple midi devices to control the visualizer which is pretty neato.

SECOND THOUGHT ON ABOVE:
Instead of the array method (too complicated for types and catching etc), we incorporate the device ID into the controlID. See the following case:

- 	The user has two different MIDI devices hooked up
- 	They assign 	88-boolean controlId 	to a number control on one device
- 	Now the second device will also trigger that control if it changes its 88-boolean control.

SOLUTION:
Incorporate the device ID into the controlID

- 	The user has two different MIDI devices hooked up
- 	They assign 	88-boolean_firstMidiDevice 		controlId to a number control on one device
- 	Now the second device won't affect the control.

Now the web MIDI API has no way of assigning unique IDs to devices, (the id field is not consistent accross OS systems, windows uses plain old index for this id value)
So the best we can do is use the device name as the ID.

So the user can't have two of the same midi devices connected, but this is a small edge case so its not too big of an issue.

[status (event), controlNumber, value]

status: 
	[128-159] 	note on/off = BOOLEAN CONTROLS
	[176-191] 	control value = NUMBER CONTROLS

controlNumber:
	[0-127]

value:
	[0-127]


MIDI CONTROL UNIQUE ID (to be used as ID for signals)

midiControlID needs to be unique, control number by itself won't work because note on/off events could share the same control number as a control value event.
The following format could be used as unique ID for control: 
	
	[controlNumber]-[midiControlType]_[midiDeviceNameFormattedForId]
	88_boolean_Launchkey-MK2-61-Launchkey-MIDI

Underscores not dashes since this id will be used in the signal function get36_note_launchkeyMk261LaunchkeyMidi

MidiControlType is an interesting one:
	There isn't really a foolproof way of knowing if the midi input is boolean or number.
	So the solution here is to just only have boolean controls respond to midi inputs if their values are 0 or 127
	BUT: there are still two kinds of MIDI events that we have to deal with and handle accordingly, there are:
	Note On/Off events + Control Value events
	Its confusing because a note off event with a value of 0 just means that the note is not off. (very unintuitive)

	So we can handle these two different types nice and early in the store.

Wasn't going to use camelcase here for midiDeviceName and instead use something that's more easily converted back and forth eg kebab case: midi-Device-Name 
But camelCase is just so clean to read, and we just have to be sure to apply the exact same conversion function to the name if we were ever going to compare ID to name

How MIDI will work with CONTROLS:

Controls can now have two types of signals, Audio or MIDI.
Eg: A number control can be hooked up to bassVolume or to a midi number control

One extra MIDI feature which I think will be very useful is the ability to also set a boolean midi control as a booster function.
So booster signals can also be of type Audio or MIDI.

This way the user can set a component as audio reactive, but also max it out on a midi button press.
Having multiple signals boosted by the same midi button press could make for some pretty neat effects.

Implementation will be similar to that of the Audio Signals, however this time the signalID will not be able to be picked from a constant set list.
Instead we will use the midiControlId that is generated when the user uses the midi listen button.

Method 1 (bit ugly):
	We can condense the Signal IDs down so it can be represented by a single ID string, then the current functionality of the controls objects doesn't have to change.

	Eg: 
		Audio Signal ID: 	audioSignal_getVolume
		Midi Signal ID: 	midiSignal_88-boolean

	All we'd have to change is the getSignalById function. Which could now:
	Parse ID into Audio | Midi type
	Fetch signal function (() => value) from either audioStore or midiStore
	Then return the signal function

	We might have some trouble with typescript 

Method 2 (bit prettier)
	We extend the current SignalFunction Id from a string to a SignalId object with more identifying features:

	type SignalIdType = 'audio' | 'midi'
	type AudioSignalId = AudioBooleanSignalId | AudioNumberSignalId
	type MidiSignalId = string // midiControlId format

	export type SignalId = {
		id: AudioSignalId | MidiSignalId 
		type: SignalIdType,
	}

	export type Signal {
		signalId: SignalId
	}


	Then we modify getSignalById function to account for the different types and fetch the correct signal function

This way in the future, we can add more signal types (eg: a beat detection signal) and all it takes is:
	An id
	Modifying the getSignalById function to fetch the correct signal function

Bonus note, all midi inputs need to be normalised to 0-1 from 0-127 since that is what the audio signals are normalised to.


Now to develop:

1. Midi Provider and Store
2. Connect Midi devices on mount (we don't actually really need to store anything at this point since we'll be using the device information on the listen button press)
3. 



Extra notes:

- We're probably going to want to configure between button holding and button pressing for midi controls
Eg: press to change to preset, but hold to boost signal